*******************************************************************************************
1) Server Component

# Render on server side
# By default, all the components are server components in nextjs
# they are closer to backend
# so BE-related logic and code should write in server components
# eg navbar , sidebar , main container

2) Client Component

# Render on client side 
# can make client component using 'use client' directive
# so UI-related logic and code should write in client components
# eg button, input etc
*******************************************************************************************
//Folder structure of the nextjs app
1) next.config.js => This file contains the configuration for the nextjs framework for that app such as basePath,devIndicators,env execute
2) jsconfig.json => This file contains the configuration for the JavaScript language throught the project
3) .eslintrc.json => This file contains the configuration for the es 6  linter tool, which helps to enforce code, it helps to provide better intellisense
4) .next => this file contains the build for the next app
5) layout.js => entry point file just like index.js in reactjs


*********************************************************************************************************************************
When you use <Component /> in your JSX, you are treating it as a React component. This means that React will create an instance of the component and manage its state and lifecycle. It can accept props just like any other React component. This is the recommended way to use components in React.

When you use {Component()} in your JSX, you are treating it as a JavaScript function call. It is not treated as a React component. This means that React will execute the Component function immediately and render the JSX returned by that function. It does not have access to React's state management or lifecycle methods.

In this case, you cannot pass props directly to Component, and it will not behave like a typical React component. It's just a function that returns JSX, and it gets called whenever your main component (Home in this case) re-renders.

**********************************************************************************************************************************

Client-Side Rendering (CSR):
----------------------------

1) In CSR, the initial HTML is generated by the client-side JavaScript running in the browser.
2) When a user navigates to a page, the browser downloads a minimal HTML document, and then JavaScript code is executed to fetch data and render the content dynamically on the client side.
3) This approach is typically faster after the initial page load, as subsequent navigation within the application does not require full page reloads.
4) However, CSR can lead to slower initial page loads, especially on slower devices or for pages with a large amount of JavaScript code to execute.


Server-Side Rendering (SSR):
----------------------------

1) In SSR, the initial HTML is generated on the server before being sent to the client.
2) When a user requests a page, the server executes the JavaScript code to generate the HTML dynamically and sends the fully rendered HTML to the client.
3) This results in faster initial page loads, especially for content-rich pages or pages with dynamic data.
4) However, SSR may lead to increased server load and slower subsequent navigation within the application, as more server resources are required for rendering each page.

********************************************************************************************************

Unhandled Runtime Error
Error: Event handlers cannot be passed to Client Component props.
  <button onClick={function} children=...>
                  ^^^^^^^^^^
If you need interactivity, consider converting part of this to a Client Component.

//if you dont specify the use-client for next js app it will try to render it in server 
so to tackle above error use 'use-client'

*****************************************************************************************
